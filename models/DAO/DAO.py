from fastapi import FastAPI, HTTPException
from pymongo import MongoClient
from config import config
from config.cache_engine import Cache
import json


# FastAPI app setup
app = FastAPI()
# MongoDB connection setup
client = MongoClient(config.DATABASE_URL)
db = client[config.DATABASE_NAME]

# Collections
gpt4o_collection = db['gpt4o']
llama31_405_collection = db['llama31_405']
gemini15_pro_collection = db['gemini15_pro']


cache = Cache()


def rank_models_by_metric(metric):
    # This is a function that retrieves the metrics data from the various collections and performs algorithms on it.
    key = ("-").join(metric.split(" "))
    res = cache.get_cache(key)
    if res:
        print(f"Cache hit for key: {key}")
        # Deserialize the JSON string back to a Python object
        return res
    else:
        print(f"Cache miss for key: {key}. Fetching from MongoDB...")

        models = [
            {"name": "GPT-4o", "avg_value": gpt4o_collection.aggregate(
                [{"$group": {"_id": None, "avg": {"$avg": f"${metric}"}}}]).next()['avg']},
            {"name": "Llama 3.1 405", "avg_value": llama31_405_collection.aggregate(
                [{"$group": {"_id": None, "avg": {"$avg": f"${metric}"}}}]).next()['avg']},
            {"name": "Gemini 1.5 Pro", "avg_value": gemini15_pro_collection.aggregate(
                [{"$group": {"_id": None, "avg": {"$avg": f"${metric}"}}}]).next()['avg']}
        ]

        # Rank models by average value (ascending)
        ranked_models = sorted(models, key=lambda x: x['avg_value'])
        cache.set_cache(key, ranked_models)
        return ranked_models


def insert_metrics(model_collection,  metric_data):
    # This is a DAO that is responsible for inserting the data generated by the randomizer into different collections.
    model_collection.insert_many(metric_data)


async def retrieve_metrics(model_collection, key):
    # This Data Access Object retrieves the data for the specified collection.
    key = ("-").join(key.split(" "))
    try:
        # Fetch the data from the Redis cache first
        res = cache.get_cache(key)
        if res:
            print(f"Cache hit for key: {key}")
            # Deserialize the JSON string back to a Python object
            return res
        else:
            print(f"Cache miss for key: {key}. Fetching from MongoDB...")

            # If not in cache, fetch the data from MongoDB
            res = list(model_collection.find({}, {"_id": 0}))

            # Store the result in cache (as a serialized JSON string)
            cache.set_cache(key, res)
            return res

    except Exception as e:
        print(f"Error occurred: {e}")
        return False
