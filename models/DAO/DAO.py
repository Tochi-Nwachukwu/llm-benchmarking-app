from fastapi import FastAPI, HTTPException
from pymongo import MongoClient
from config import settings
from utils.cache import set_cache, get_cache
from utils.logger import Logger
import json

logger = Logger()
# MongoDB connection setup
client = MongoClient(settings.DATABASE_URL)
db = client[settings.DATABASE_NAME]

# Collections
gpt4o_collection = db["gpt4o"]
llama31_405_collection = db["llama31_405"]
gemini15_pro_collection = db["gemini15_pro"]

component_name = "DAO"


def rank_models_by_metric(metric):
    # This is a function that retrieves the metrics data from the various collections and performs aggregates it.
    key = ("-").join(metric.split(" "))
    res = get_cache(key)
    if res:
        logger.log(
            component_name + "-rank_models_by_metric", f"Cache hit for key: {key}"
        )
        return json.loads(res)
    else:
        logger.log(
            component_name + "-rank_models_by_metric",
            f"Cache miss for key: {
            key}. Fetching from MongoDB Cloud database ...",
        )

        models = [
            {
                "name": "GPT-4o",
                "avg_value": gpt4o_collection.aggregate(
                    [{"$group": {"_id": None, "avg": {"$avg": f"${metric}"}}}]
                ).next()["avg"],
            },
            {
                "name": "Llama 3.1 405",
                "avg_value": llama31_405_collection.aggregate(
                    [{"$group": {"_id": None, "avg": {"$avg": f"${metric}"}}}]
                ).next()["avg"],
            },
            {
                "name": "Gemini 1.5 Pro",
                "avg_value": gemini15_pro_collection.aggregate(
                    [{"$group": {"_id": None, "avg": {"$avg": f"${metric}"}}}]
                ).next()["avg"],
            },
        ]

        # This python function ranks the Rank models by average value (ascending)
        ranked_models = sorted(models, key=lambda x: x["avg_value"])
        set_cache(key, ranked_models)
        return ranked_models


def insert_metrics(model_collection, metric_data):
    # This is a DAO that is responsible for inserting the data generated by the randomizer into different collections.
    model_collection.insert_many(metric_data)


async def retrieve_metrics(model_collection, key):
    # This Data Access Object retrieves the data for the specified collection.
    key = ("-").join(key.split(" "))
    try:
        # Fetch the data from the  Cache first, and see if the data exists in the cache. if it is not there, it will proceed to use the database connection for this
        res = get_cache(key)
        if res:
            logger.log(
                component_name + "-retrieve_metrics", f"Cache hit for key: {key}"
            )
            return json.loads(res)
        else:
            logger.log(
                component_name + "-retrieve_metrics",
                f"Cache miss for key: {key}. Fetching from MongoDB...",
            )
            res = list(model_collection.find({}, {"_id": 0}))
            set_cache(key, res)
            return res

    except Exception as e:
        logger.log(component_name + "-retrieve_metrics", f"Error occurred: {e}")
        return False
